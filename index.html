<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>SONALIA: COSMIC PIPELINE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-title {
            position: absolute; top: 40px; left: 40px;
            border-left: 4px solid #fff; padding-left: 20px;
            background: linear-gradient(90deg, rgba(0,10,20,0.9), transparent);
            transition: border-color 0.3s;
        }
        h1 { margin: 0; font-size: 36px; color: #fff; text-shadow: 0 0 20px currentColor; letter-spacing: 4px; }
        p { margin: 5px 0 0; color: #aaa; font-size: 14px; letter-spacing: 2px; font-family: monospace; }

        /* C:F METER (Interactive Gradient) */
        #cf-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 600px; text-align: center; pointer-events: auto;
        }
        .cf-bar-bg {
            width: 100%; height: 10px; background: #222; border-radius: 5px;
            position: relative; margin-top: 15px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); border: 1px solid #555;
            overflow: hidden;
        }
        /* グラデーション背景 */
        .cf-gradient {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff0055); opacity: 0.3;
        }
        .cf-knob {
            width: 24px; height: 24px; background: #fff; border-radius: 50%; 
            position: absolute; top: -7px; left: 50%; transform: translateX(-50%);
            box-shadow: 0 0 15px #fff; transition: left 0.05s; cursor: grab;
        }
        .cf-labels { 
            display: flex; justify-content: space-between; font-size: 12px; font-weight: bold; 
            text-shadow: 0 0 5px #000;
        }
        .label-c { color: #00ffff; }
        .label-f { color: #ff0055; }

        /* PANEL */
        #panel {
            position: absolute; top: 0; right: 0; width: 400px; height: 100%;
            background: rgba(5, 8, 12, 0.96); border-left: 1px solid #333;
            transform: translateX(100%); transition: 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            color: #eee; display: flex; flex-direction: column; z-index: 20; pointer-events: auto;
            backdrop-filter: blur(10px);
        }
        #panel.active { transform: translateX(0); }
        .p-head { padding: 40px 30px; border-bottom: 1px solid #333; background: linear-gradient(180deg, rgba(255,255,255,0.05), transparent); }
        .p-tag { font-size: 10px; padding: 4px 10px; border-radius: 2px; color: #000; font-weight: 800; background: #fff; }
        .p-title { font-size: 28px; margin: 15px 0 0; color: #fff; text-shadow: 0 0 15px currentColor; }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        .row { margin-bottom: 30px; }
        .label { font-size: 11px; border-bottom: 1px solid rgba(255,255,255,0.2); display: block; margin-bottom: 8px; letter-spacing: 1px; color: #aaa; }
        .text { font-size: 14px; line-height: 1.8; color: #ccc; }
        .thought { font-family: monospace; color: #fff; background: rgba(255,255,255,0.05); padding: 15px; border-left: 3px solid #fff; }
        .close-btn { position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; color: #777; }
        .close-btn:hover { color: #fff; }

        /* LOADER */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s; cursor: pointer;
        }
        .load-text { font-size: 50px; color: #fff; font-weight: 900; letter-spacing: 10px; text-shadow: 0 0 30px #00ffff; }
        .load-sub { color: #00ffff; font-family: monospace; margin-top: 20px; animation: blink 1s infinite; letter-spacing: 3px; }
        @keyframes blink { 50% { opacity: 0.3; } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.120.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loader" onclick="startApp()">
        <div class="load-text">SONALIA</div>
        <div class="load-sub">LOADING COSMIC SYSTEM...</div>
    </div>

    <div id="ui-layer">
        <div id="hud-title">
            <h1>思考回路マップ</h1>
            <p>4D COSMIC PIPELINE</p>
        </div>

        <div id="cf-container">
            <div class="cf-labels">
                <span class="label-c">COGNITION (思考)</span>
                <span class="label-f">FEELING (感情)</span>
            </div>
            <div class="cf-bar-bg" id="cf-track">
                <div class="cf-gradient"></div>
                <div class="cf-knob" id="cf-knob"></div>
            </div>
        </div>
    </div>

    <div id="panel">
        <div class="close-btn" onclick="closePanel()">×</div>
        <div class="p-head">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div class="row"><span class="label">DEFINITION</span><div class="text" id="p-desc">...</div></div>
            <div class="row"><span class="label">SYSTEM ROLE</span><div class="text" id="p-role">...</div></div>
            <div class="row"><span class="label">INTERNAL VOICE</span><div class="thought" id="p-thought">...</div></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- DATA ---
        const NODES = [
            // 1. INPUT (Head)
            { id:"IN", type:"INPUT", name:"五感入力", color:0xFFFFFF, x:0, y:0, z:-200, size:10, desc:"外界情報の取得。", role:"Input", thought:"(Sensing)" },
            // 2. OS (Chest)
            { id:"OS4", type:"OS", name:"時間/協調", color:0xFFD700, x:0, y:0, z:-130, size:8, desc:"大局的判断。", role:"Meta View", thought:"「将来は？」" },
            { id:"OS3", type:"OS", name:"報酬/意味", color:0xAA00FF, x:0, y:0, z:-110, size:8, desc:"価値判断。", role:"Value", thought:"「意味ある？」" },
            { id:"OS2", type:"OS", name:"評価/所属", color:0x3388FF, x:0, y:0, z:-90, size:8, desc:"社会的判断。", role:"Social", thought:"「正しい？」" },
            { id:"OS1", type:"OS", name:"生存/生活", color:0x00FFFF, x:0, y:0, z:-70, size:8, desc:"生存本能。", role:"Survival", thought:"「安全？」" },
            // 3. DB (Stomach)
            { id:"DB1", type:"DB", name:"欲求DB", color:0xFF5500, x:-35, y:-15, z:20, size:12, desc:"根源的渇望。", role:"Motivation", thought:"(Desire)" },
            { id:"DB2", type:"DB", name:"情動DB", color:0x0044FF, x:35, y:-15, z:20, size:12, desc:"感情記憶。", role:"Emotion", thought:"(Feeling)" },
            { id:"DB3", type:"DB", name:"価値観DB", color:0xFFCC00, x:35, y:-15, z:-40, size:12, desc:"信念体系。", role:"Belief", thought:"(Rule)" },
            { id:"DB4", type:"DB", name:"無意識DB", color:0x888888, x:-35, y:-15, z:-40, size:12, desc:"自動反応。", role:"Reflex", thought:"(Habit)" },
            // 4. FACTOR (Waist)
            { id:"IQ", type:"係数", name:"IQ", color:0x00CCFF, z:80, angle:0, size:9, desc:"論理力。", role:"Logic", thought:"分析" },
            { id:"EQ", type:"係数", name:"EQ", color:0xFF6666, z:80, angle:1, size:9, desc:"感情力。", role:"Empathy", thought:"共感" },
            { id:"SQ", type:"係数", name:"SQ", color:0xFFCC00, z:80, angle:2, size:9, desc:"社会性。", role:"Social", thought:"適応" },
            { id:"AQ", type:"係数", name:"AQ", color:0x888888, z:80, angle:3, size:9, desc:"逆境力。", role:"Resilience", thought:"忍耐" },
            { id:"CQ", type:"係数", name:"CQ", color:0xAA00FF, z:80, angle:4, size:9, desc:"創造力。", role:"Idea", thought:"発想" },
            { id:"HQ", type:"係数", name:"HQ", color:0xFFFFFF, z:80, angle:5, size:9, desc:"人間力。", role:"Ethics", thought:"誠実" },
            { id:"MQ", type:"係数", name:"MQ", color:0xFF3300, z:80, angle:6, size:9, desc:"行動力。", role:"Action", thought:"実行" },
            { id:"KQ", type:"係数", name:"KQ", color:0x00FF88, z:80, angle:7, size:9, desc:"知識力。", role:"Knowledge", thought:"応用" },
            // 5. OUTPUT (Feet)
            { id:"OUT", type:"OUTPUT", name:"行動", color:0xFFFFFF, x:0, y:0, z:200, size:12, desc:"最終出力。", role:"Output", thought:"(Act)" }
        ];

        // --- ENGINE ---
        let scene, camera, renderer, controls;
        let mainGroup, glowTex, particleSystem;
        let cfRatio = 0.5;
        const interactables = [];
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Colors
        const COL_C = new THREE.Color(0x00ffff); // Cyan (Cognition)
        const COL_F = new THREE.Color(0xff0055); // Pink (Feeling)

        function init() {
            scene = new THREE.Scene();
            // 宇宙的な深いフォグ
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 3000);
            camera.position.set(350, 150, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = 0.2;

            mainGroup = new THREE.Group();
            mainGroup.rotation.z = -Math.PI / 2; // Horizontal
            scene.add(mainGroup);

            glowTex = createGlowTex();

            // Build
            buildCosmicPipeline();
            buildNodes();
            buildParticleStream(); // The massive flow
            buildEnvironment(); // Stars

            // Slider Init
            setupSlider();

            animate();
            setTimeout(startApp, 1500);
        }

        function createGlowTex() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0, 32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.2, 'rgba(255,255,255,0.3)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        // 1. Cosmic Pipeline (The Thick Tube)
        function buildCosmicPipeline() {
            // Main Tube
            const path = new THREE.LineCurve3(new THREE.Vector3(0,0,-220), new THREE.Vector3(0,0,220));
            const tubeGeo = new THREE.TubeGeometry(path, 20, 8, 16, false); // Thicker pipe
            const tubeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.05, wireframe: true });
            const tube = new THREE.Mesh(tubeGeo, tubeMat);
            mainGroup.add(tube);
            // Save ref for color update
            tube.userData.isPipeline = true;

            // Inner Core Line
            const lineGeo = new THREE.Geometry();
            lineGeo.vertices.push(new THREE.Vector3(0,0,-220), new THREE.Vector3(0,0,220));
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            mainGroup.add(new THREE.Line(lineGeo, lineMat));
        }

        // 2. Nodes
        function buildNodes() {
            NODES.forEach(d => {
                let mesh;
                const col = new THREE.Color(d.color);

                if(d.type === 'OS') {
                    const geo = new THREE.TorusGeometry(45, 0.5, 16, 64);
                    mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.6 }));
                    mesh.position.z = d.z;
                    const hit = new THREE.Mesh(new THREE.CylinderGeometry(45,45,10,16), new THREE.MeshBasicMaterial({visible:false}));
                    hit.rotation.x = Math.PI/2; hit.position.z = d.z; hit.userData = { data: d };
                    interactables.push(hit); mainGroup.add(hit);

                } else if(d.type === '係数') {
                    const r = 70;
                    const ang = (d.angle/8)*Math.PI*2;
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(10,10,10), new THREE.MeshBasicMaterial({ color: col, wireframe: true }));
                    mesh.position.set(Math.cos(ang)*r, Math.sin(ang)*r, d.z);
                    mesh.userData = { data: d }; interactables.push(mesh);
                    
                    // Connection
                    const pts = [new THREE.Vector3(0,0,d.z), new THREE.Vector3(Math.cos(ang)*r, Math.sin(ang)*r, d.z)];
                    const lGeo = new THREE.BufferGeometry().setFromPoints(pts);
                    mainGroup.add(new THREE.Line(lGeo, new THREE.LineBasicMaterial({color:col, opacity:0.3, transparent:true})));

                } else {
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(d.size, 16, 16), new THREE.MeshBasicMaterial({ color: col, wireframe: d.type==='DB' }));
                    mesh.position.set(d.x||0, d.y||0, d.z);
                    mesh.userData = { data: d }; interactables.push(mesh);
                }

                if(mesh) {
                    const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: col, blending: THREE.AdditiveBlending }));
                    spr.scale.set(d.size*4 || 40, d.size*4 || 40, 1);
                    mesh.add(spr); mainGroup.add(mesh);
                }
            });
        }

        // 3. Particle Stream (Massive Flow)
        function buildParticleStream() {
            const count = 500; // More particles
            const pGeo = new THREE.Geometry();
            
            for(let i=0; i<count; i++) {
                pGeo.vertices.push(new THREE.Vector3(0,0,0));
                pGeo.colors.push(new THREE.Color(0xffffff));
            }
            
            const pMat = new THREE.PointsMaterial({ size: 3, map: glowTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, vertexColors: true });
            particleSystem = new THREE.Points(pGeo, pMat);
            
            // State per particle
            particleSystem.userData = {
                particles: Array(count).fill().map(() => ({
                    z: -220 + Math.random()*440,
                    speed: 2 + Math.random()*3,
                    offset: Math.random() * Math.PI * 2,
                    radius: Math.random() * 8
                }))
            };
            mainGroup.add(particleSystem);
        }

        // 4. Environment (Stars)
        function buildEnvironment() {
            const pGeo = new THREE.Geometry();
            for(let i=0; i<1000; i++) {
                pGeo.vertices.push(new THREE.Vector3(
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000
                ));
            }
            const pMat = new THREE.PointsMaterial({ color: 0x888888, size: 1.5, transparent: true, opacity: 0.5 });
            scene.add(new THREE.Points(pGeo, pMat));
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            const time = clock.getElapsedTime();

            // 1. System Color Update (C:F Gradient)
            const currentMixColor = new THREE.Color().lerpColors(COL_C, COL_F, cfRatio);
            
            // Update Pipeline Color
            mainGroup.children.forEach(c => {
                if(c.userData.isPipeline) {
                    c.material.color.lerp(currentMixColor, 0.1);
                }
            });

            // Update UI Colors
            const uiTitle = document.getElementById('hud-title');
            if(uiTitle) uiTitle.style.borderColor = '#'+currentMixColor.getHexString();
            const uiText = document.querySelector('h1');
            if(uiText) uiText.style.textShadow = `0 0 20px #${currentMixColor.getHexString()}`;


            // 2. Particle Flow Logic
            const pGeo = particleSystem.geometry;
            const pData = particleSystem.userData.particles;
            
            pData.forEach((p, i) => {
                p.z += p.speed * (1 + cfRatio * 0.5); // Emotion accelerates flow
                
                let r = p.radius;
                let x = 0, y = 0;

                // DB Swirl Logic (Stomach area z = -10 to +30)
                if(p.z > -20 && p.z < 20) {
                    // Swirl out
                    r = 30 + Math.sin(time*5 + p.offset)*10;
                    p.z += p.speed * -0.5; // Slow down
                }

                x = Math.cos(time*2 + p.offset + p.z*0.02) * r;
                y = Math.sin(time*2 + p.offset + p.z*0.02) * r;

                pGeo.vertices[i].set(x, y, p.z);
                
                // Color: Mix white with Current Theme
                pGeo.colors[i].lerpColors(new THREE.Color(0xffffff), currentMixColor, 0.5);

                if(p.z > 220) p.z = -220;
            });
            pGeo.verticesNeedUpdate = true;
            pGeo.colorsNeedUpdate = true;

            renderer.render(scene, camera);
        }

        // --- SLIDER & INTERACTION ---
        function setupSlider() {
            const track = document.getElementById('cf-track');
            const knob = document.getElementById('cf-knob');
            
            track.addEventListener('mousedown', updateSlider);
            window.addEventListener('mousemove', e => { if(track.userData.dragging) updateSlider(e); });
            window.addEventListener('mouseup', () => track.userData.dragging = false);
            track.addEventListener('mousedown', () => track.userData.dragging = true);

            function updateSlider(e) {
                const rect = track.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let pct = Math.max(0, Math.min(1, x / rect.width));
                cfRatio = pct;
                knob.style.left = (pct * 100) + '%';
            }
        }

        window.addEventListener('mousedown', e => {
            if(e.target.closest('#panel') || e.target.closest('#cf-container')) return;
            
            controls.autoRotate = false; 
            setTimeout(() => controls.autoRotate = true, 3000);

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            
            if(hits.length > 0) {
                showPanel(hits[0].object.userData.data);
            } else {
                closePanel();
            }
        });

        function showPanel(d) {
            // Dynamic color based on C:F or Node Color
            const nodeColor = new THREE.Color(d.color);
            const themeColor = new THREE.Color().lerpColors(COL_C, COL_F, cfRatio);
            const displayColor = d.type.includes("OS") ? nodeColor : themeColor;

            document.getElementById('p-tag').innerText = d.type;
            document.getElementById('p-tag').style.background = '#'+displayColor.getHexString();
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = '#'+displayColor.getHexString();
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            document.getElementById('panel').classList.add('active');
        }
        function closePanel() { document.getElementById('panel').classList.remove('active'); }
        window.closePanel = closePanel;

        function startApp() {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => { document.getElementById('loader').style.display='none'; }, 500);
        }
        window.startApp = startApp;

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;

    </script>
</body>
</html>
