<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>SONALIA: PARTICLE CORE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #hud-header {
            position: absolute; top: 40px; left: 40px;
            border-left: 4px solid #00ffff; padding-left: 20px;
            background: linear-gradient(90deg, rgba(0,20,30,0.8), transparent);
        }
        h1 { margin: 0; font-size: 32px; color: #fff; text-shadow: 0 0 20px #00ffff; letter-spacing: 4px; }
        p { margin: 5px 0 0; color: #00ffff; font-size: 12px; letter-spacing: 2px; }

        /* C:F SLIDER (Interactive) */
        #control-box {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 300px; text-align: center; pointer-events: auto;
            background: rgba(0, 10, 20, 0.8); padding: 20px; border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        .slider-labels { display: flex; justify-content: space-between; font-size: 10px; font-weight: bold; margin-bottom: 10px; }
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #fff; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px #fff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: linear-gradient(90deg, #00ffff, #ff0055); border-radius: 2px;
        }
        #cf-status { margin-top: 8px; font-size: 11px; color: #00ffff; font-family: monospace; }

        /* PANEL */
        #panel {
            position: absolute; top: 0; right: 0; width: 380px; height: 100%;
            background: rgba(8, 12, 16, 0.95); border-left: 1px solid #333;
            transform: translateX(100%); transition: 0.3s;
            color: #eee; display: flex; flex-direction: column; z-index: 20; pointer-events: auto;
        }
        #panel.active { transform: translateX(0); }
        .p-head { padding: 40px 30px; border-bottom: 1px solid rgba(255,255,255,0.1); background: linear-gradient(180deg, rgba(0,255,255,0.1), transparent); }
        .p-tag { font-size: 10px; padding: 3px 8px; border-radius: 2px; background: #00ffff; color: #000; font-weight: bold; }
        .p-title { font-size: 28px; margin: 15px 0 0; color: #fff; }
        .p-body { padding: 30px; overflow-y: auto; flex: 1; }
        .label { font-size: 11px; color: #00ffff; border-bottom: 1px solid rgba(255,255,255,0.2); display: block; margin-bottom: 8px; }
        .text { font-size: 14px; line-height: 1.7; color: #ccc; }
        .thought { font-family: monospace; color: #fff; background: rgba(0,255,255,0.05); padding: 15px; border-left: 3px solid #00ffff; }
        .close-btn { position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; color: #fff; }

        /* LOADER */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s; cursor: pointer;
        }
        .load-text { font-size: 40px; color: #fff; font-weight: bold; letter-spacing: 5px; text-shadow: 0 0 20px #00ffff; }
        .load-sub { color: #00ffff; font-family: monospace; margin-top: 10px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        #error-log { position:absolute; bottom:10px; color:red; font-size:10px; display:none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loader" onclick="startApp()">
        <div class="load-text">SONALIA</div>
        <div class="load-sub">LOADING PARTICLE SYSTEM...</div>
        <div id="error-log"></div>
    </div>

    <div id="ui-layer">
        <div id="hud-header">
            <h1>人体構造モデル</h1>
            <p>4D PARTICLE VISUALIZER</p>
        </div>
        
        <div id="control-box">
            <div class="slider-labels">
                <span style="color:#00ffff">思考 (C)</span>
                <span style="color:#ff0055">感情 (F)</span>
            </div>
            <input type="range" id="cf-slider" min="0" max="100" value="50">
            <div id="cf-status">MODE: BALANCED</div>
        </div>
    </div>

    <div id="panel">
        <div class="close-btn" onclick="closePanel()">×</div>
        <div class="p-head">
            <span class="p-tag" id="p-tag">TAG</span>
            <h2 class="p-title" id="p-title">Title</h2>
        </div>
        <div class="p-body">
            <div style="margin-bottom:20px"><span class="label">DEFINITION</span><div class="text" id="p-desc">...</div></div>
            <div style="margin-bottom:20px"><span class="label">ROLE</span><div class="text" id="p-role">...</div></div>
            <div style="margin-bottom:20px"><span class="label">THOUGHT</span><div class="thought" id="p-thought">...</div></div>
        </div>
    </div>

    <script>
        // Error Handler
        window.onerror = function(msg) {
            document.getElementById('error-log').style.display='block';
            document.getElementById('error-log').innerText = msg;
        };

        // --- DATA ---
        const DATA = [
            // Head
            { id:"SENSE", type:"INPUT", name:"五感入力", y:140, desc:"視覚・聴覚などの外界情報。", role:"情報収集", thought:"(Sensing...)" },
            // Chest (OS Rings)
            { id:"OS4", type:"OS(4層)", name:"時間/協調", y:90, desc:"過去未来・自他バランス。", role:"大局観", thought:"「将来は？相手は？」" },
            { id:"OS3", type:"OS(3層)", name:"報酬/意味", y:75, desc:"損得・意義の判断。", role:"価値判断", thought:"「得か？意味あるか？」" },
            { id:"OS2", type:"OS(2層)", name:"評価/所属", y:60, desc:"善悪・集団帰属。", role:"社会性", thought:"「正しいか？浮いてないか？」" },
            { id:"OS1", type:"OS(1層)", name:"生存/生活", y:45, desc:"安全・ルーティン。", role:"生存本能", thought:"「危なくないか？」" },
            // Stomach (DB)
            { id:"DB1", type:"DB", name:"欲求DB", y:10, x:-20, z:20, desc:"根源的渇望。", role:"Motivation", thought:"(Deep Desire)" },
            { id:"DB2", type:"DB", name:"情動DB", y:10, x:20, z:20, desc:"感情記憶。", role:"Emotion", thought:"(Flashback)" },
            { id:"DB3", type:"DB", name:"価値観DB", y:10, x:20, z:-20, desc:"信念・ルール。", role:"Belief", thought:"(Core Rule)" },
            { id:"DB4", type:"DB", name:"無意識DB", y:10, x:-20, z:-20, desc:"反射的クセ。", role:"Reflex", thought:"(Auto-Pilot)" },
            // Waist (Factors)
            { id:"IQ", type:"係数", name:"IQ", y:-30, angle:0, desc:"論理力。", role:"Logic", thought:"分析" },
            { id:"EQ", type:"係数", name:"EQ", y:-30, angle:1, desc:"感情力。", role:"Empathy", thought:"共感" },
            { id:"SQ", type:"係数", name:"SQ", y:-30, angle:2, desc:"社会性。", role:"Social", thought:"適応" },
            { id:"AQ", type:"係数", name:"AQ", y:-30, angle:3, desc:"逆境力。", role:"Resilience", thought:"忍耐" },
            { id:"CQ", type:"係数", name:"CQ", y:-30, angle:4, desc:"創造力。", role:"Idea", thought:"発想" },
            { id:"HQ", type:"係数", name:"HQ", y:-30, angle:5, desc:"人間力。", role:"Ethics", thought:"誠実" },
            { id:"MQ", type:"係数", name:"MQ", y:-30, angle:6, desc:"行動力。", role:"Action", thought:"実行" },
            { id:"KQ", type:"係数", name:"KQ", y:-30, angle:7, desc:"知識力。", role:"Know-How", thought:"応用" },
            // Output
            { id:"OUT", type:"OUTPUT", name:"行動出力", y:-100, desc:"最終的な言動。", role:"Output", thought:"(Act)" }
        ];

        let scene, camera, renderer, controls;
        let humanPoints, systemGroup, flowSystem;
        let cfRatio = 0.5; // 0.0(Cyan) - 1.0(Pink)
        const interactables = [];
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 3000);
            camera.position.set(0, 20, 380);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Controls
            if(window.THREE && window.THREE.OrbitControls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
            }

            // --- BUILD ---
            buildParticleHuman();
            buildSystemNodes();
            buildNeuralFlow();

            // --- EVENTS ---
            window.addEventListener('resize', onResize);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            document.getElementById('cf-slider').addEventListener('input', onSliderChange);

            animate();
            setTimeout(startApp, 1000);
        }

        // Texture
        function createGlowTex() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.1)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }
        const glowTex = createGlowTex();

        // 1. Particle Human
        function buildParticleHuman() {
            const geo = new THREE.Geometry();
            const count = 3000;
            
            for(let i=0; i<count; i++) {
                const y = (Math.random() * 280) - 130;
                let rMax = 0;
                if (y > 100) rMax = 22; // Head
                else if (y > 80) rMax = 12; // Neck
                else if (y > 10) rMax = 50; // Chest
                else if (y > -50) rMax = 40; // Waist
                else rMax = 45; // Legs

                const ang = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * rMax; // Uniform distribution
                
                const v = new THREE.Vector3(Math.cos(ang)*r, y, Math.sin(ang)*r);
                geo.vertices.push(v);
                
                // Init Color (Cyan)
                const col = new THREE.Color().setHSL(0.5, 1.0, 0.5 + Math.random()*0.3);
                geo.colors.push(col);
            }
            
            const mat = new THREE.PointsMaterial({ size: 2, vertexColors: true, map: glowTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
            humanPoints = new THREE.Points(geo, mat);
            scene.add(humanPoints);
        }

        // 2. System Nodes (Interactive)
        function buildSystemNodes() {
            systemGroup = new THREE.Group();
            scene.add(systemGroup);

            DATA.forEach(d => {
                let mesh;
                const col = 0x00ffff; // Default Base Color

                if (d.type.includes("OS")) {
                    const geo = new THREE.TorusGeometry(35, 0.2, 16, 64);
                    mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.5 }));
                    mesh.rotation.x = Math.PI/2;
                    mesh.position.y = d.y;
                    
                    // Hit Sphere
                    const hit = new THREE.Mesh(new THREE.SphereGeometry(35,8,8), new THREE.MeshBasicMaterial({visible:false}));
                    hit.position.y = d.y;
                    hit.userData = { data: d };
                    interactables.push(hit);
                    systemGroup.add(hit);

                } else if (d.type === "DB") {
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(6, 16, 16), new THREE.MeshBasicMaterial({ color: col, wireframe: true }));
                    mesh.position.set(d.x, d.y, d.z);
                    mesh.userData = { data: d };
                    interactables.push(mesh);

                } else if (d.type === "係数") {
                    const r = 50;
                    const ang = (d.angle/8)*Math.PI*2;
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,6), new THREE.MeshBasicMaterial({ color: col, wireframe: true }));
                    mesh.position.set(Math.cos(ang)*r, d.y, Math.sin(ang)*r);
                    mesh.userData = { data: d };
                    interactables.push(mesh);
                
                } else if (d.id === "SENSE") {
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(3), new THREE.MeshBasicMaterial({color:0xffffff}));
                    mesh.position.y = d.y;
                    mesh.userData = { data: d };
                    interactables.push(mesh);
                }

                if(mesh && mesh.visible !== false) {
                    // Glow Sprite
                    const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: col, blending: THREE.AdditiveBlending }));
                    spr.scale.set(30,30,1);
                    mesh.add(spr);
                    systemGroup.add(mesh);
                }
            });
        }

        // 3. Flow
        function buildNeuralFlow() {
            const geo = new THREE.Geometry();
            for(let i=0; i<200; i++) {
                geo.vertices.push(new THREE.Vector3(0,0,0));
            }
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 3, map: glowTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
            flowSystem = new THREE.Points(geo, mat);
            flowSystem.userData = {
                particles: Array(200).fill().map(() => ({
                    y: 140 + Math.random()*50,
                    speed: 1 + Math.random()*2,
                    offset: Math.random()*Math.PI*2
                }))
            };
            scene.add(flowSystem);
        }

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            if(controls) controls.update();
            const time = Date.now() * 0.001;

            // 1. Color Shift (C -> F)
            const targetColor = new THREE.Color().lerpColors(new THREE.Color(0x00ffff), new THREE.Color(0xff0055), cfRatio);
            
            // Update Human Particles
            humanPoints.geometry.colors.forEach(c => {
                // Add noise
                c.copy(targetColor).offsetHSL(0, 0, (Math.random()-0.5)*0.2); 
            });
            humanPoints.geometry.colorsNeedUpdate = true;
            
            // Update System Nodes
            systemGroup.children.forEach(child => {
                if(child.material && child.material.color) child.material.color.lerp(targetColor, 0.1);
                if(child.children.length > 0 && child.children[0].material) child.children[0].material.color.lerp(targetColor, 0.1);
            });

            // 2. Pulse
            const beat = 1 + Math.sin(time * (2 + cfRatio*5)) * 0.01;
            humanPoints.scale.set(beat, beat, beat);

            // 3. Flow
            const positions = flowSystem.geometry.vertices;
            const pData = flowSystem.userData.particles;
            
            pData.forEach((p, i) => {
                p.y -= p.speed * (1 + cfRatio); // Speed up with Emotion
                const r = 5 + Math.sin(time*5 + p.offset) * 10 * cfRatio; // Chaos with Emotion
                const x = Math.cos(time*3 + p.offset) * r;
                const z = Math.sin(time*3 + p.offset) * r;
                
                if(p.y < -120) p.y = 140; // Reset
                
                positions[i].set(x, p.y, z);
            });
            flowSystem.geometry.verticesNeedUpdate = true;
            
            // Change flow color to white/pink mix
            flowSystem.material.color.lerpColors(new THREE.Color(0xffffff), new THREE.Color(0xffaaaa), cfRatio);

            renderer.render(scene, camera);
        }

        // --- INTERACTION ---
        function onSliderChange(e) {
            cfRatio = e.target.value / 100;
            const txt = document.getElementById('cf-status');
            if(cfRatio < 0.4) txt.innerText = "MODE: COGNITION (思考優位)";
            else if(cfRatio > 0.6) txt.innerText = "MODE: FEELING (感情優位)";
            else txt.innerText = "MODE: BALANCED (バランス)";
            
            txt.style.color = cfRatio > 0.5 ? '#ff0055' : '#00ffff';
        }

        function onMouseDown(e) {
            if(e.target.closest('#panel') || e.target.closest('#control-box')) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            
            if(hits.length > 0) {
                const d = hits[0].object.userData.data;
                // Current color
                const c = new THREE.Color().lerpColors(new THREE.Color(0x00ffff), new THREE.Color(0xff0055), cfRatio);
                showPanel(d, c);
            } else {
                closePanel();
            }
        }
        
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(interactables);
            document.body.style.cursor = hits.length > 0 ? 'pointer' : 'default';
        }

        function showPanel(d, col) {
            document.getElementById('p-tag').innerText = d.type;
            document.getElementById('p-tag').style.background = '#'+col.getHexString();
            document.getElementById('p-title').innerText = d.name;
            document.getElementById('p-title').style.color = '#'+col.getHexString();
            document.getElementById('p-desc').innerText = d.desc;
            document.getElementById('p-role').innerText = d.role;
            document.getElementById('p-thought').innerText = d.thought;
            document.getElementById('panel').classList.add('active');
        }
        function closePanel() {
            document.getElementById('panel').classList.remove('active');
        }
        window.closePanel = closePanel;

        function startApp() {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => { document.getElementById('loader').style.display='none'; }, 800);
        }
        window.startApp = startApp;

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;

    </script>
</body>
</html>
